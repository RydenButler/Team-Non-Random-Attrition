nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 2 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp<-dgp.func(2000, p.sim1, q=0, confounder=2)
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1 # naive OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
thisProp1 <- Proposition1(data.tmp1) # store results of Prop. 1 using simulated data
thisProp2 <- Proposition2(data.tmp1) # store results of Prop. 2 using simulated data
thisProp3 <- Proposition3(data.tmp1) # store results of Prop. 3 using simulated data
thisProp4 <- Proposition4(data.tmp1) # store results of Prop. 4 using simulated data
thisProp5 <- Proposition5(data.tmp1) # store results of Prop. 4 using simulated data
out1[i, 5] <- thisProp1$ATE # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- thisProp2$ATE # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- thisProp3$ATE # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- thisProp4$ATE # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- thisProp5$ATE # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(thisProp1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(thisProp1$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(thisProp2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(thisProp2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(thisProp3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(thisProp3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(thisProp4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(thisProp4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(thisProp5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(thisProp5$weights) # store min IPW for Prop. 5
rm(list = c("data.tmp1", "thisProp1", "thisProp2", "thisProp3", "thisProp4", "thisProp5"))
}
##Calculate errors in point estimation for each simulation
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] - 1 # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
#par(mfrow = c(4, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control and attrition on unobservables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) Induced imbalance in Treatment/Control and attrition on unobservables")
abline(h = 0)
#############################################################################
### Simulations for Propositions 1-5 Using dgp.func WITH creating imbalance in X
## across Treatment/Control among non-attritted but WITH unmeasured confounders related
## to both attrition and outcome ###
#############################################################################
nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 1 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp <- dgp.func(2000, p.sim1, q=1.5, confounder=2)
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1 # naive OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
thisProp1 <- Proposition1(data.tmp1) # store results of Prop. 1 using simulated data
thisProp2 <- Proposition2(data.tmp1) # store results of Prop. 2 using simulated data
thisProp3 <- Proposition3(data.tmp1) # store results of Prop. 3 using simulated data
thisProp4 <- Proposition4(data.tmp1) # store results of Prop. 4 using simulated data
thisProp5 <- Proposition5(data.tmp1) # store results of Prop. 5 using simulated data
out1[i, 5] <- thisProp1$ATE # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- thisProp2$ATE # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- thisProp3$ATE # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- thisProp4$ATE # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- thisProp5$ATE # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(thisProp1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(thisProp1$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(thisProp2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(thisProp2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(thisProp3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(thisProp3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(thisProp4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(thisProp4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(thisProp5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(thisProp5$weights) # store min IPW for Prop. 5
rm(list = c("data.tmp1", "thisProp1", "thisProp2", "thisProp3", "thisProp4", "thisProp5"))
}
##Calculate errors in point estimation for each simulation
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] - 1 # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
# par(mfrow = c(1, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control and attrition on observables & unobservables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) Induced imbalance in Treatment/Control and attrition on observables & unobservables")
abline(h = 0)
library(MASS)
library(devtools)
library(roxygen2)
library(MASS)
library(gam)
library(parallel)
setwd("C://Users//drmiller1220//Documents//GitHub//Team-Non-Random-Attrition")
Current <- as.package('attritR')
load_all(Current)
document(Current)
library(MASS)
library(gam)
layout(matrix(c(1,2,3,4,5,6,7,8), ncol=2, byrow=TRUE),
heights = c(0.25,0.25,0.25,0.25))
# generating simulation data in a format to be used by functions below
dgp.func <- function(n, p, q = 0, instr=2, confounder=0, error_type="normal"){
D = as.numeric(sample(n) <= (n/2)) # Treat half of sample
#For Logit Errors
if(error_type=="logit"){
e <- runif(n, 0, 1) # Generate random uniform(0,1) errors
e <- e/(1-e) # Errors expressed as odds
e <- log(e)*3 # Log odds
}
if(error_type=="normal"){
e <- rnorm(n, 0, 3) # generate random normal(0,1) errors
}
X <- rnorm(n) # Draw X random standard normal
Z <- rnorm(n)  # Draw instrument Z random normal
u <-rnorm(n) # Unobserved confunder
latentr <- p*X + p*D + q*X*D + instr*Z + confounder*u+e # Response propensity ~ p*X + p*D + q*X:D ;
R <- latentr # Store response propensity as R
R[latentr <  1] <- 0 # Recode score < 1 as response
R[latentr >= 1] <- 1 # Recode score >= 1 as non-response
y.star <- 1 + 1*D + .5*X + 1*(D*X) + confounder*u + rnorm(n) # Y ~ D*X
data.sim <- as.data.frame(cbind(X, D, Z, y.star, R, u)) # Store in data frame
data.sim$Y <- data.sim$y.star # Store responses as Y
data.sim$Y[data.sim$R == 1] <- NA # Recode non-response as NA
data.sim$R.tilde <- 1 - data.sim$R # Store R.tilde as indicator where 1 == response
return(list(data=data.sim, ATER1=1+mean(X[R==0])*1, ATE=1+mean(X)*1))
}
sample_data <- dgp.func(1000, 1)
sample_data <- sample_data$data
R.tilde <- sample_data$R.tilde
sample_data <- subset(sample_data, select=c(Y, D, X, Z))
# pWeights generated by collaborative effort
pWeights <- gam(R.tilde ~ D + X + Z,
family = binomial(link = logit),
data = sample_data)$fitted
# pWeights generated by attritR probabilityFits function
pWeights_pf <- probabilityFits(R.tilde ~ D + X + Z, sample_data, binomial(link = logit))
# pWeights generated by attritR calculateWeights function (which uses probabilityFits)
pWeights_cw <- calculateWeights(sample_data[,1:3], sample_data[,4])$pW_Inst
# difference between collaborate effort and attritR (converges to 0)
pWeights_diff <- pWeights - pWeights_cw
# # pi weights for population generated by collaborative effort
#
# PiWeights_All <- glm(D ~ X + pWeights,
#                  family = binomial(link = logit),
#                  data = sample_data)$fitted
# PiWeights_All[sample_data$D == 0] <- 1 - PiWeights_All[sample_data$D == 0]
#
# # pi weights for population generated by probabilityFits in attritR
#
# PiWeights_All_pf <- probabilityFits(D ~ X + pWeights, sample_data, binomial(link = logit))
# PiWeights_All_pf[sample_data$D == 0] <- 1 - PiWeights_All_pf[sample_data$D == 0]
#
# # pi weights for population generated by calculateWeights in attritR
#
# PiWeights_All_cw <- calculateWeights(sample_data[,1:3], sample_data[,4])$Pi_All
#
# # difference between pi weights for population from attritR and collaborative effort
# # (converges to 0)
#
# PiWeights_All_diff <- PiWeights_All - PiWeights_All_cw
# subsetting data for respondents only to estimate pi weights for respondents only
RespondentData <- sample_data[!is.na(sample_data$Y), ]
RespondentData$pWeights <- pWeights[which(!is.na(sample_data$Y))]
# pi weights for respondents generated by collaborative effort
PiWeights_Resp <- glm(D ~ X + pWeights,
family = binomial(link = logit),
data = RespondentData)$fitted
PiWeights_Resp[RespondentData$D == 0] <- 1 - PiWeights_Resp[RespondentData$D == 0]
# pi weights for respondents generated by probabilityFits in attritR
PiWeights_Resp_pf <- probabilityFits(D ~ X + pWeights, RespondentData, binomial(link = logit))
PiWeights_Resp_pf[RespondentData$D == 0] <- 1 - PiWeights_Resp_pf[RespondentData$D == 0]
# pi weights for respondents generated by calculateWeights in attritR
PiWeights_Resp_cw <- calculateWeights(sample_data[,1:3], sample_data[,4])$Pi_Resp
# difference between pi weights for respondents from attritR and collaborative effort
# (converges to 0)
PiWeights_Resp_diff <- PiWeights_Resp - PiWeights_Resp_cw
####################
# generate simulated data
sample_data <- dgp.func(1000, 1)
sample_data <- sample_data$data
# extract ATE and weights for each of the 5 propositions using the hard-coded
# from the other file (load those functions into your environment manually)
Prop1_coll <- Proposition1(sample_data)
Prop1_coll_ATE <- Prop1_coll$ATE
Prop1_coll_weights <- Prop1_coll$weights
Prop2_coll <- Proposition2(sample_data)
Prop2_coll_ATE <- Prop2_coll$ATE
Prop2_coll_weights <- Prop2_coll$weights
Prop3_coll <- Proposition3(sample_data)
Prop3_coll_ATE <- Prop3_coll$ATE
Prop3_coll_weights <- Prop3_coll$weights
Prop4_coll <- Proposition4(sample_data)
Prop4_coll_ATE <- Prop4_coll$ATE
Prop4_coll_weights <- Prop4_coll$weights
Prop5_coll <- Proposition5(sample_data)
Prop5_coll_ATE <- Prop5_coll$ATE
Prop5_coll_weights <- Prop5_coll$weights
Prop5_coll_weights1 <- Prop5_coll$PiWeights
# run estimateDelta from attritR (load the package manually); estimateDelta will
# return the results from all 5 propositions.  Code extracts the ATEs and weights
# for each proposition
package_answers <- estimateDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data = sample_data)
Prop1_pack <- package_answers$Prop1
Prop1_pack_ATE <- Prop1_pack$coefficients[2]
Prop1_pack_weights <- package_answers$pW_Obs_T
# weights are extracted from the package rather than the lm object for Prop1 in order to
# be comparable to the hard-coded function
Prop2_pack <- package_answers$Prop2
Prop2_pack_ATE <- Prop2_pack$coefficients[2]
Prop2_pack_weights <- 1/Prop2_pack$weights
Prop3_pack <- package_answers$Prop3
Prop3_pack_ATE <- Prop3_pack$coefficients[2]
Prop3_pack_weights <- 1/Prop3_pack$weights
Prop4_pack <- package_answers$Prop4
Prop4_pack_ATE <- Prop4_pack$coefficients[2]
Prop4_pack_weights <- 1/Prop4_pack$weights
Prop5_pack <- package_answers$Prop5
Prop5_pack_ATE <- Prop5_pack$coefficients[2]
Prop5_pack_weights <- 1/Prop5_pack$weights
# assess the difference between the weights from the hard-coded functions and from
# the package
Prop1_weights_diff <- Prop1_coll_weights - Prop1_pack_weights
Prop2_weights_diff <- Prop2_coll_weights - Prop2_pack_weights
Prop3_weights_diff <- Prop3_coll_weights - Prop3_pack_weights
Prop4_weights_diff <- Prop4_coll_weights - Prop4_pack_weights
Prop5_weights_diff <- Prop5_coll_weights - Prop5_pack_weights
################################
### Simulations for Propositions 1-5 Using dgp.func ###
nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 2 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp<-dgp.func(2000, p.sim1)
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE#lm(y.star ~ D + X + u, data=data.tmp1)$coef[2] # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1#lm(Y ~ D + X + u, data=data.tmp1)$coef[2] # OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
propPack <- estimateDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data.tmp1) # using function from attritR to run all 5 props
Prop1 <- propPack$Prop1 # store results of Prop. 1 using simulated data
Prop2 <- propPack$Prop2 # store results of Prop. 2 using simulated data
Prop3 <- propPack$Prop3 # store results of Prop. 3 using simulated data
Prop4 <- propPack$Prop4 # store results of Prop. 4 using simulated data
Prop5 <- propPack$Prop5 # store results of Prop. 5 using simulated data
out1[i, 5] <- Prop1$coefficients[2] # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- Prop2$coefficients[2] # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- Prop3$coefficients[2] # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- Prop4$coefficients[2] # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- Prop5$coefficients[2] # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(1/Prop1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(1/Prop2$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(1/Prop2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(1/Prop2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(1/Prop3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(1/Prop3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(1/Prop4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(1/Prop4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(1/Prop5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(1/Prop5$weights) # store min IPW for Prop. 5
rm(list = c("gen.tmp", "data.tmp1", "Prop1", "Prop2", "Prop3", "Prop4", "Prop5"))
}
##Calculate errors in point estimation for each simulation (all obsevrations)
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] - 1#out1[ , 1] # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
#par(mfrow = c(4, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) No induced imbalance in Treatment/Control\n and attrition on observables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) No induced imbalance in Treatment/Control\n and attrition on observables")
abline(h = 0)
#Results1
#############################################################################
### Simulations for Propositions 1-5 Using dgp.func creating imbalance in X
## across Treatment/Control among non-attritted ###
#############################################################################
nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 2 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp <- dgp.func(2000, p.sim1, q=1.5) # simulate data
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1 # naive OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D, data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
propPack <- estimateDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data.tmp1) # using function from attritR to run all 5 props
Prop1 <- propPack$Prop1 # store results of Prop. 1 using simulated data
Prop2 <- propPack$Prop2 # store results of Prop. 2 using simulated data
Prop3 <- propPack$Prop3 # store results of Prop. 3 using simulated data
Prop4 <- propPack$Prop4 # store results of Prop. 4 using simulated data
Prop5 <- propPack$Prop5 # store results of Prop. 5 using simulated data
out1[i, 5] <- Prop1$coefficients[2] # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- Prop2$coefficients[2] # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- Prop3$coefficients[2] # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- Prop4$coefficients[2] # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- Prop5$coefficients[2] # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(1/Prop1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(1/Prop1$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(1/Prop2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(1/Prop2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(1/Prop3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(1/Prop3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(1/Prop4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(1/Prop4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(1/Prop5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(1/Prop5$weights) # store min IPW for Prop. 5
rm(list = c("gen.tmp", "data.tmp1", "Prop1", "Prop2", "Prop3", "Prop4", "Prop5"))
}
##Calculate errors in point estimation for each simulation
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] -1 # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
#par(mfrow = c(4, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control\n and attrition on observables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) Induced imbalance in Treatment/Control\n and attrition on observables")
abline(h = 0)
#############################################################################
### Simulations for Propositions 1-5 Using dgp.func without creating imbalance in X
## across Treatment/Control among non-attritted but WITH unmeasured confounders related
## to both attrition and outcome ###
#############################################################################
nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 2 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp<-dgp.func(2000, p.sim1, q=0, confounder=2)
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1 # naive OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
propPack <- estimateDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data.tmp1) # using function from attritR to run all 5 props
Prop1 <- propPack$Prop1 # store results of Prop. 1 using simulated data
Prop2 <- propPack$Prop2 # store results of Prop. 2 using simulated data
Prop3 <- propPack$Prop3 # store results of Prop. 3 using simulated data
Prop4 <- propPack$Prop4 # store results of Prop. 4 using simulated data
Prop5 <- propPack$Prop5 # store results of Prop. 5 using simulated data
out1[i, 5] <- Prop1$coefficients[2] # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- Prop2$coefficients[2] # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- Prop3$coefficients[2] # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- Prop4$coefficients[2] # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- Prop5$coefficients[2] # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(1/Prop1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(1/Prop1$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(1/Prop2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(1/Prop2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(1/Prop3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(1/Prop3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(1/Prop4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(1/Prop4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(1/Prop5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(1/Prop5$weights) # store min IPW for Prop. 5
rm(list = c("gen.tmp", "data.tmp1", "Prop1", "Prop2", "Prop3", "Prop4", "Prop5"))
}
##Calculate errors in point estimation for each simulation
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] - 1 # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
#par(mfrow = c(4, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control\n and attrition on unobservables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) Induced imbalance in Treatment/Control\n and attrition on unobservables")
abline(h = 0)
#############################################################################
### Simulations for Propositions 1-5 Using dgp.func WITH creating imbalance in X
## across Treatment/Control among non-attritted AND WITH unmeasured confounders related
## to both attrition and outcome ###
#############################################################################
nsim1 <- 500 # set number of simulations
out1 <- matrix(NA, nsim1, 9) # empty matrix for estimate comparisons
weights1 <- matrix(NA, nsim1, 10) # empty matrix for weight comparisons
p.sim1 <- 1 #
for(i in 1:nsim1){ # iterate over simulations
gen.tmp <- dgp.func(2000, p.sim1, q=1.5, confounder=2)
data.tmp1 <- gen.tmp$data # simulate data
out1[i, 1] <- gen.tmp$ATE # OLS estimate under no attrition
out1[i, 2] <- gen.tmp$ATER1 # naive OLS estimate for respondents under no attrition
out1[i, 3] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i, 4] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
propPack <- estimateDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data.tmp1) # using function from attritR to run all 5 props
Prop1 <- propPack$Prop1 # store results of Prop. 1 using simulated data
Prop2 <- propPack$Prop2 # store results of Prop. 2 using simulated data
Prop3 <- propPack$Prop3 # store results of Prop. 3 using simulated data
Prop4 <- propPack$Prop4 # store results of Prop. 4 using simulated data
Prop5 <- propPack$Prop5 # store results of Prop. 5 using simulated data
out1[i, 5] <- Prop1$coefficients[2] # Prop. 1 IPW OLS ATE estimate
out1[i, 6] <- Prop2$coefficients[2] # Prop. 2 IPW OLS ATE estimate
out1[i, 7] <- Prop3$coefficients[2] # Prop. 3 IPW OLS ATE estimate
out1[i, 8] <- Prop4$coefficients[2] # Prop. 4 IPW OLS ATE estimate
out1[i, 9] <- Prop5$coefficients[2] # Prop. 5 IPW OLS ATE estimate
weights1[i, 1] <- max(1/Prop1$weights) # store max IPW for Prop. 1
weights1[i, 2] <- min(1/Prop1$weights) # store min IPW for Prop. 1
weights1[i, 3] <- max(1/Prop2$weights) # store max IPW for Prop. 2
weights1[i, 4] <- min(1/Prop2$weights) # store min IPW for Prop. 2
weights1[i, 5] <- max(1/Prop3$weights) # store max IPW for Prop. 3
weights1[i, 6] <- min(1/Prop3$weights) # store min IPW for Prop. 3
weights1[i, 7] <- max(1/Prop4$weights) # store max IPW for Prop. 4
weights1[i, 8] <- min(1/Prop4$weights) # store min IPW for Prop. 4
weights1[i, 9] <- max(1/Prop5$weights) # store max IPW for Prop. 5
weights1[i, 10] <- min(1/Prop5$weights) # store min IPW for Prop. 5
rm(list = c("gen.tmp", "data.tmp1", "Prop1", "Prop2", "Prop3", "Prop4", "Prop5"))
}
##Calculate errors in point estimation for each simulation
ateErrors <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- out1[ , (i + 2)] - 1 # stores the bias of each estimator
}
##Calculate errors in point estimation for each simulation (respondents only)
ateErrorsR1 <- matrix(NA, nrow = nsim1, ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- out1[ , (i + 2)] - out1[ , 2] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
# par(mfrow = c(1, 2), mar = c(1, 2, 1, .1), mgp = c(1, 0, 0), tcl = 0) # set plot parameters
# Plot box and whiskers for bias of each estimator
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control\n and attrition on observables & unobservables")
abline(h = 0)
boxplot(ateErrorsR1[,c(2,4,6)], ylab = "Bias", main = " (ATE|R=1) Induced imbalance in Treatment/Control\n and attrition on observables & unobservables")
abline(h = 0)
