2+2
source('~/.active-rstudio-document')
print("Hello world")
31 %/% 7 # The integer part of a fraction
4%%2
4%%3
f1 <- factor(letters)
levels(f1)
levels(f1) <- rev(levels(f1))
f1
f2<- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
a <-c(1,2)
dim(a)
b <- matrix(1:4, ncol=2)
b
is.matrix(b)
is.array(b)
x1 <- array(1:5, c(1, 1, 5))
x2 <- array(1:5, c(1, 5, 1))
x3 <- array(1:5, c(5, 1, 1))
x1
x2
x3
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 ) # should be 10
install.packages('MCMCpack')
install.packages('lmer')
install.packages('lme4')
install.packages("BAS") # This will prompt a user interface to choose the "mirror" or repository
n = 200
sum((1:n)^2)
n*(n+1)*(2n+1)/6
n*(n+1)*(2*n+1)/6
n = 200
sum((1:n)^2)
n*(n+1)*(2*n+1)/6
n = 400
sum((1:n)^2)
n*(n+1)*(2*n+1)/6
n = 600
sum((1:n)^2)
n*(n+1)*(2*n+1)/6
n = 800
sum((1:n)^2)
n*(n+1)*(2*n+1)/6
rep(seq(1,4), rep(4,5))
rep(4,5)
rep(5,5)
rep(seq(1,4), rep(5,5))
seq(0,4)
rep(seq(0,4), rep(5,5))
rep(seq(1,5), 5)
c(seq(1,5), seq(2,6), seq(3,7), seq(4,8), seq(5,9))
?sample
x <- sample(-100:100, size=100)
x
seq(1,100,by=2)
x[seq(1,100,by=2)] <- -1*x[seq(1,100,by=2)]
x
paste("Var", seq(1,6), sep="")
varnames <- paste("Var", seq(1,6), sep="")
gsub("Var", varnames)
gsub("Var", x = varnames)
gsub("Var", replacement='', x = varnames)
varnames <- gsub("Var", replacement='', x = varnames)
as.numeric(varnames)
varnames <- as.numeric(varnames)
x <- 1:100
y <- 100:1
x%*%y
varnames2 <- varnames%%1
varnames
varnames%%1
varnames%%2
varnames%%2==1
varnames2 <- varnames[varnames%%1]
varnames
varnames2 <- varnames[varnames%%2==1]
varnames2
varnames - varnames2
varnames
varnames2
seq_len(length.out = 5)
rep(seq_len(length.out = 5),5)
seq(seq(1,5), length.out = 5)
seq_len(2,5)
seq(seq(1,5), length.out = 5)
seq(2, length.out=5)
x
x <- sample(-100:100, size=100)
x
x%%2==1
x[x%%2==1] <- -1*x[x%%2==1]
x
seq(1, length.out = 5)
seq(1, length.out = 5)
rep(seq(1, length.out = 5))
rep(seq(1, length.out = 5),2)
seq(seq(1, length.out = 5), 2)
seq(seq(1, length.out = 5)[2], 2)
seq(1, length.out = 5)
seq(1, length.out = 5)[2]
seq(seq(1, length.out = 5)[2], length.out = 5)
seq(seq(seq(1, length.out = 5)[2], length.out = 5)[2], length.out = 5)
seq(1, length.out = 5)
rep(seq(1,9),2)
rep(seq(1,9),c(1,2,3)
#3
variance <- function(x){
1/(length(x)-1)*sum((x - mean(x))^2)
}
#4
?sample
# samples a pre-defined number of elements from the vector x, either with or without replacement
#5
x <- sample(-100:100, size=100)
# odd index
x[seq(1,100,by=2)] <- -1*x[seq(1,100,by=2)]
# odd numbers
x[x%%2==1] <- -1*x[x%%2==1]
#6
x <- 1:100
y <- 100:1
x%*%y
#7
varnames <- paste("Var", seq(1,6), sep="")
#8
varnames <- gsub("Var", replacement='', x = varnames)
#9
varnames <- as.numeric(varnames)
#10
varnames2 <- varnames[varnames%%2==1]
#11
varnames - varnames2
rep(seq(1,9),c(1,2,3))
seq(1, length.out = 5)
seq(2, along.with = seq_len(5))
apply(x, 1:2, seq(x, length.out = 5))
apply(x, 1, seq(x, length.out = 5))
lapply(1:5, mean)
vapply(1:5, mean)
seq(1, 5, by=c(1,2,2))
seq(1, 5, by=c(1,2))
seq(1, 5, by=2)
seq(1, 5, by=3)
seq(1, 5, by=-2)
rep(seq(0,4), rep(5,5)) + seq(1,5)
rep(seq(0,4), rep(5,5))
install.packages('RSelenium')
library(RSelenium)
library(RSelenium)
checkForServer()
Server java binary
startServer()
require(RSelenium)
remDr <- remoteDriver(remoteServerAddr = "localhost"
, port = 4445L
, browserName = "chrome"
)
remDr$open()
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 ) # should be 10
devtools::install_github("jamesdunham/dgo", dependencies = TRUE)
install.packages('devtools')
library(devtools)
devtools::install_github("jamesdunham/dgo", dependencies = TRUE)
devtools::install_github("jamesdunham/dgo", dependencies = TRUE)
devtools::install_github("jamesdunham/dgo", dependencies = TRUE)
devtools::install_github("jamesdunham/dgo", dependencies = F)
library(dgo)
library(foreign)
library(survival)
library(survminer)
ProtestData <- read.dta('final_data_v10.dta')
drop(1:3 %*% 2:4)
1:3 %*% 2:4
dim(drop(array(1:12, dim = c(1,3,1,1,2,1,2))))
drop(array(1:12, dim = c(1,3,1,1,2,1,2)))
array(1:12, dim = c(1,3,1,1,2,1,2))
array(1:12, dim = c(1,3,1,1,2,1,2))
drop(array(1:12, dim = c(1,3,1,1,2,1,2)))
drop(drop(array(1:12, dim = c(1,3,1,1,2,1,2))))
library(doMC)
library(foreach)
registerDoMC(cores=2)
SecondAttempt <- function(slices) {
MyArray <- replicate(slices, matrix(runif(20*5, 1, 10), ncol = 5), simplify = 'array')
Beta <- matrix(c(1,2,0,4,0), ncol=1)
Y <- aaply(.data = MyArray, .margins = 3,
.fun = function(x, b) x%*%b + rnorm(20,10, 1), b = Beta,
.parallel = T)
BetaHat <- aaply(.data = 1:slices, .margins = 1,
.fun = function(x) lm(Y[x, ] ~ MyArray[ , , x])$coefficients[1:6],
.parallel = T)
apply(BetaHat, 2, function(x) plot(density(x)))
}
FirstAttempt <- function(slices) {
MyArray <- replicate(slices, matrix(runif(20*5, 1, 10), ncol = 5), simplify = 'array')
Beta <- matrix(c(1,2,0,4,0), ncol=1)
Y <- aaply(.data = MyArray, .margins = 3,
.fun = function(x, b) x%*%b + rnorm(20,10, 1), b = Beta)
BetaHat <- aaply(.data = 1:slices, .margins = 1,
.fun = function(x) lm(Y[x, ] ~ MyArray[ , , x])$coefficients[1:6])
apply(BetaHat, 2, function(x) plot(density(x)))
}
system.time(FirstAttempt(1000)) # 1.417   0.073   1.491
system.time(SecondAttempt(1000)) # 3.574   2.307   2.186
system.time(FirstAttempt(10000)) # 11.794   0.169  12.036
system.time(SecondAttempt(10000)) # 37.965  24.413  39.348
library(plyr)
FirstAttempt <- function(slices) {
MyArray <- replicate(slices, matrix(runif(20*5, 1, 10), ncol = 5), simplify = 'array')
Beta <- matrix(c(1,2,0,4,0), ncol=1)
Y <- aaply(.data = MyArray, .margins = 3,
.fun = function(x, b) x%*%b + rnorm(20,10, 1), b = Beta)
BetaHat <- aaply(.data = 1:slices, .margins = 1,
.fun = function(x) lm(Y[x, ] ~ MyArray[ , , x])$coefficients[1:6])
apply(BetaHat, 2, function(x) plot(density(x)))
}
FirstAttempt(1000)
#5) Re-run that code in parallel.  How does the system time compare for the parallel version?
library(doMC)
library(foreach)
registerDoMC(cores=2)
SecondAttempt <- function(slices) {
MyArray <- replicate(slices, matrix(runif(20*5, 1, 10), ncol = 5), simplify = 'array')
Beta <- matrix(c(1,2,0,4,0), ncol=1)
Y <- aaply(.data = MyArray, .margins = 3,
.fun = function(x, b) x%*%b + rnorm(20,10, 1), b = Beta,
.parallel = T)
BetaHat <- aaply(.data = 1:slices, .margins = 1,
.fun = function(x) lm(Y[x, ] ~ MyArray[ , , x])$coefficients[1:6],
.parallel = T)
apply(BetaHat, 2, function(x) plot(density(x)))
}
SecondAttempt(1000)
system.time(FirstAttempt(1000)) # 1.417   0.073   1.491
system.time(SecondAttempt(1000)) # 3.574   2.307   2.186
system.time(FirstAttempt(10000)) # 11.794   0.169  12.036
system.time(SecondAttempt(10000)) # 37.965  24.413  39.348
system.time(FirstAttempt(50000)) # 164.663   1.066 166.091
system.time(SecondAttempt(50000))
system.time(FirstAttempt(100000))
system.time(SecondAttempt(100000))
library(XML)
myURL <- 'http://www.cbssports.com/collegebasketball/scoreboard/div1/20170221'
allTables <- readHTMLTable(myURL)
str(allTables)  # Look at the allTables object to find the specific table we want
oneGame <- allTables[[1]]
oneGame
as.character(oneGame$V1)
as.numeric(as.character(oneGame$V5))
as.Date(101010)
as.Date('101010')
Dates
date()
states
letters
days
dates
Sys.time()
library(parallel)
detectCores()
getwd()
setwd("~/Dropbox/Team-Non-Random-Attrition")
package.skeleton('estimateDelta')
Y <- c(1,2,3)
X <- c(5,5,5)
data.frame(cbind(Y,X))
