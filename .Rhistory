names=c("Democrats", "Republicans", "Independents"),
col=c("dodgerblue", "firebrick1", "forestgreen"),
ylab="Percent Approving", main="Presidential Approval by Party")
text(x=bar, y=c(5,75,5), label=c(paste0(round(dem_app, 0),"%"), paste0(round(gop_app,0),"%"), paste0(round(ind_app,0), "%")))
dem_app
sum(survey_data$presapp[which(survey_data$pid3=="Democrat")], na.rm = TRUE)
sum(survey_data$pid3=="Republican", na.rm = TRUE)
library(pwr)
pwr.t2n.test(d=0.2, sig.level = 0.05)
pwr.t2n.test(d=0.2, sig.level = 0.05, power = 0.8)
pwr.t.test(d=0.2, sig.level = 0.05, power = 0.8)
pwr.t.test(d=0.15, sig.level = 0.05, power = 0.8)
pwr.t.test(d=0.15, sig.level = 0.05, power = 0.7)
pwr.t.test(d=0.2, sig.level = 0.05, power = 0.7)
pwr.t.test(d=0.15, sig.level = 0.05, power = 0.7)
load("x.rdata")
load("C:\\Users\\drmiller1220\\Dropbox\\Attrition-Experiments\\sim_results.rdata")
ateErrors <- matrix(NA, nrow = dim(sim_results)[1], ncol = 7) # empty matrix for error comparisons
View(sim_results)
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrors[ , i] <- sim_results[ , (i + 12)] - sim_results[,11] # stores the bias of each estimator
}
ateErrorsR1 <- matrix(NA, nrow = dim(sim_results)[1], ncol = 7) # empty matrix for error comparisons
for(i in 1:7){ # iterates over columns 3:9 of the estimate comparison matrix
ateErrorsR1[ , i] <- sim_results[ , (i + 12)] - sim_results[ , 12] # stores the bias of each estimator
}
colnames(ateErrors) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrors)
colnames(ateErrorsR1) <- c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.", "Prop. 4", "Prop 5.")
summary(ateErrorsR1)
head(weights1) ## Shows minimum and maximum predicted probabilities
boxplot(ateErrors[,c(1,2,3,5,7)], ylab = "Bias", main = " (ATE) Induced imbalance in Treatment/Control\n and attrition on observables")
abline(h = 0)
ateErrors[,c(1,2,3,5,7)]
colmeans(ateErrors[,c(1,2,3,5,7)])
colMeans(ateErrors[,c(1,2,3,5,7)])
library(MASS)
library(devtools)
library(roxygen2)
library(MASS)
library(gam)
library(parallel)
### load in attritR package
setwd("C://Users//drmiller1220//Documents//GitHub//Team-Non-Random-Attrition")
Current <- as.package('attritR')
load_all(Current)
document(Current)
###
# this function generates the data we use in a given simulation; latent.r.coef are the coefficients
# for the response propensity score model; y.star.coef are the coefficients for the true y, or
# y.star, model
dgp.func <- function(n, latent.r.coef = list(attrit_param = 1, # parameter indicating severity
# of attrition
hetero_attrit = 0, # parameter indicating degree of
# heterogeneous effect of treatment
# on attrition
confounder = 2,    # parameter for unobserved confounder
instr = 1),        # parameter for instrument
y.star.coef = list(intercept=1,
D_coef=1,               # parameter for treatment effect on Y
X_coef=.5,              # parameter for X on Y
DX_coef=1,
confounder=2),              # parameter for heterogeneous treatment effect
error_type="normal"){                    # select either normal or logit errors
D = as.numeric(sample(n) <= (n/2)) # Treat half of sample
#For Logit Errors
if(error_type=="logit"){
e <- runif(n, 0, 1) # Generate random uniform(0,1) errors
e <- e/(1-e) # Errors expressed as odds
e <- log(e)*3 # Log odds
}
if(error_type=="normal"){
e <- rnorm(n, 0, 3) # generate random normal(0,1) errors
}
X <- rnorm(n) # Draw X random standard normal
Z <- rnorm(n)  # Draw instrument Z random normal
u <-rnorm(n) # Unobserved confunder
latentr <- latent.r.coef$attrit_param*X + latent.r.coef$attrit_param*D + latent.r.coef$hetero_attrit*X*D + latent.r.coef$instr*Z + latent.r.coef$confounder*u+e # Response propensity ~ p*X + p*D + q*X:D ;
R <- latentr # Store response propensity as R
R[latentr <  1] <- 0 # Recode score < 1 as non-response
R[latentr >= 1] <- 1 # Recode score >= 1 as response
y.star <- y.star.coef$intercept + y.star.coef$D_coef*D + y.star.coef$X_coef*X +
y.star.coef$DX_coef*(D*X) + y.star.coef$confounder*u + rnorm(n) # true Y, or Y star, as a function of treatment, X, D*X, and confounder
data.sim <- as.data.frame(cbind(X, D, Z, y.star, R, u)) # Store in data frame
data.sim$Y <- data.sim$y.star # Store responses as Y
data.sim$Y[data.sim$R == 0] <- NA # Recode non-response as NA
param.sim <- c("attrit_param"=latent.r.coef$attrit_param,
"hetero_attrit"=latent.r.coef$hetero_attrit,
"confounder"=latent.r.coef$confounder,
"instr"=latent.r.coef$instr,
"intercept"=y.star.coef$intercept,
"D_coef"=y.star.coef$D_coef,
"X_coef"=y.star.coef$X_coef,
"DX_coef"=y.star.coef$DX_coef)
return(list(data=data.sim, ATER1=y.star.coef$D_coef+mean(X[R==1])*y.star.coef$DX_coef,
ATE=y.star.coef$D_coef+mean(X)*y.star.coef$DX_coef))
}
d <- dgp.func(200)
#####################################
sim_results <- data.frame("latent.r.attrit_param"=numeric(0),
"latent.r.hetero_param"=numeric(0),
"latent.r.confounder"=numeric(0),
"latent.r.instr"=numeric(0),
"y.star.int"=numeric(0),
"y.star.D"=numeric(0),
"y.star.X"=numeric(0),
"y.star.DX"=numeric(0),
"y.star.confounder"=numeric(0),
"ATE_True"=numeric(0),
"ATER1_True"=numeric(0),
"OLS_NC_Est"=numeric(0),
"OLS_C_Est"=numeric(0),
"Prop1_Est"=numeric(0),
"Prop2_Est"=numeric(0),
"Prop3_Est"=numeric(0),
"Prop4_Est"=numeric(0),
"Prop5_Est"=numeric(0),
"Prop1_MinWeight"=numeric(0),
"Prop2_MinWeight"=numeric(0),
"Prop3_MinWeight"=numeric(0),
"Prop4_MinWeight"=numeric(0),
"Prop5_MinWeight"=numeric(0),
"Prop1_MaxWeight"=numeric(0),
"Prop2_MaxWeight"=numeric(0),
"Prop3_MaxWeight"=numeric(0),
"Prop4_MaxWeight"=numeric(0),
"Prop5_MaxWeight"=numeric(0),
"OLS_NC_Lower"=numeric(0),
"OLS_C_Lower"=numeric(0),
"Prop1_Lower"=numeric(0),
"Prop2_Lower"=numeric(0),
"Prop3_Lower"=numeric(0),
"Prop4_Lower"=numeric(0),
"Prop5_Lower"=numeric(0),
"OLS_NC_Upper"=numeric(0),
"OLS_C_Upper"=numeric(0),
"Prop1_Upper"=numeric(0),
"Prop2_Upper"=numeric(0),
"Prop3_Upper"=numeric(0),
"Prop4_Upper"=numeric(0),
"Prop5_Upper"=numeric(0)
)
sim_func <- function(n_sims_data, storage_df){ # specify number of data points per simulation, and the df with parameter values and slots to store results
#for(i in 1:n_sims_per){ # iterate over simulations
dgp.func <- function(n, latent.r.coef = list(attrit_param = 1, # parameter indicating severity
# of attrition
hetero_attrit = 0, # parameter indicating degree of
# heterogeneous effect of treatment
# on attrition
confounder = 2,    # parameter for unobserved confounder
instr = 1),        # parameter for instrument
y.star.coef = list(intercept=1,
D_coef=1,               # parameter for treatment effect on Y
X_coef=.5,              # parameter for X on Y
DX_coef=1,
confounder=2),              # parameter for heterogeneous treatment effect
error_type="normal"){                    # select either normal or logit errors
D = as.numeric(sample(n) <= (n/2)) # Treat half of sample
#For Logit Errors
if(error_type=="logit"){
e <- runif(n, 0, 1) # Generate random uniform(0,1) errors
e <- e/(1-e) # Errors expressed as odds
e <- log(e)*3 # Log odds
}
if(error_type=="normal"){
e <- rnorm(n, 0, 3) # generate random normal(0,1) errors
}
X <- rnorm(n) # Draw X random standard normal
Z <- rnorm(n)  # Draw instrument Z random normal
u <-rnorm(n) # Unobserved confunder
latentr <- latent.r.coef$attrit_param*X + latent.r.coef$attrit_param*D + latent.r.coef$hetero_attrit*X*D + latent.r.coef$instr*Z + latent.r.coef$confounder*u+e # Response propensity ~ p*X + p*D + q*X:D ;
R <- latentr # Store response propensity as R
R[latentr <  1] <- 0 # Recode score < 1 as non-response
R[latentr >= 1] <- 1 # Recode score >= 1 as response
y.star <- y.star.coef$intercept + y.star.coef$D_coef*D + y.star.coef$X_coef*X +
y.star.coef$DX_coef*(D*X) + y.star.coef$confounder*u + rnorm(n) # true Y, or Y star, as a function of treatment, X, D*X, and confounder
data.sim <- as.data.frame(cbind(X, D, Z, y.star, R, u)) # Store in data frame
data.sim$Y <- data.sim$y.star # Store responses as Y
data.sim$Y[data.sim$R == 0] <- NA # Recode non-response as NA
param.sim <- c("latent.r.coef.attrit_param"=latent.r.coef$attrit_param,
"latent.r.coef.hetero_attrit"=latent.r.coef$hetero_attrit,
"latent.r.coef.confounder"=latent.r.coef$confounder,
"latent.r.coef.instr"=latent.r.coef$instr,
"y.star.intercept"=y.star.coef$intercept,
"y.star.D_coef"=y.star.coef$D_coef,
"y.star.X_coef"=y.star.coef$X_coef,
"y.star.DX_coef"=y.star.coef$DX_coef,
"y.star.confounder"=y.star.coef$confounder)
return(list(data=data.sim, ATER1=y.star.coef$D_coef+mean(X[R==1])*y.star.coef$DX_coef,
ATE=y.star.coef$D_coef+mean(X)*y.star.coef$DX_coef,
sim_params = param.sim))
}
ind_sim <- function(k){
gen.tmp<-dgp.func(n_sims_data,  # specify number of data points per simulation
latent.r.coef = list(attrit_param = k$latent.r.attrit_param,
hetero_attrit = k$latent.r.hetero_param,
confounder = k$latent.r.confounder,
instr = k$latent.r.instr),
y.star.coef = list(intercept = k$y.star.int,
D_coef = k$y.star.D,
X_coef = k$y.star.X,
DX_coef = k$y.star.DX,
confounder = k$y.star.confounder),
error_type="normal")
data.tmp1 <- gen.tmp$data # simulate data
ATE_True <- gen.tmp$ATE
ATER1_True <- gen.tmp$ATER1
OLS_NC_Est <- lm(Y ~ D , data=data.tmp1)$coef[2]
OLS_C_Est <- lm(Y ~ D + X, data=data.tmp1)$coef[2]
OLS_NC_SE <- coef(summary(lm(Y ~ D , data=data.tmp1)))[2,2]
OLS_C_SE <- coef(summary(lm(Y ~ D + X, data=data.tmp1)))[2,2]
OLS_NC_Lower <- confint(lm(Y ~ D , data=data.tmp1))[2,1]
OLS_NC_Upper <- confint(lm(Y ~ D , data=data.tmp1))[2,2]
OLS_C_Lower <- confint(lm(Y ~ D + X, data=data.tmp1))[2,1]
OLS_C_Upper <- confint(lm(Y ~ D + X, data=data.tmp1))[2,2]
propPack <- bootstrapDelta(Y ~ D + X,
instrumentFormula = ~ Z,
data.tmp1)
Prop1_Est <- propPack$Means$Prop1[2]
Prop2_Est <- propPack$Means$Prop2[2]
Prop3_Est <- propPack$Means$Prop3[2]
Prop4_Est <- propPack$Means$Prop4[2]
Prop5_Est <- propPack$Means$Prop5[2]
Prop1_SE <- propPack$SD$Prop1[2]
Prop2_SE <- propPack$SD$Prop2[2]
Prop3_SE <- propPack$SD$Prop3[2]
Prop4_SE <- propPack$SD$Prop4[2]
Prop5_SE <- propPack$SD$Prop5[2]
Prop1_MaxWeight <- propPack$MaxWeights$Prop1
Prop1_MinWeight <- propPack$MinWeights$Prop1
Prop2_MaxWeight <- propPack$MaxWeights$Prop2
Prop2_MinWeight <- propPack$MinWeights$Prop2
Prop3_MaxWeight <- propPack$MaxWeights$Prop3
Prop3_MinWeight <- propPack$MinWeights$Prop3
Prop4_MaxWeight <- propPack$MaxWeights$Prop4
Prop4_MinWeight <- propPack$MinWeights$Prop4
Prop5_MaxWeight <- propPack$MaxWeights$Prop5
Prop5_MinWeight <- propPack$MinWeights$Prop5
Prop1_Lower <- propPack$Quants$Prop1[1,2]
Prop1_Upper <- propPack$Quants$Prop1[2,2]
Prop2_Lower <- propPack$Quants$Prop2[1,2]
Prop2_Upper <- propPack$Quants$Prop2[2,2]
Prop3_Lower <- propPack$Quants$Prop3[1,2]
Prop3_Upper <- propPack$Quants$Prop3[2,2]
Prop4_Lower <- propPack$Quants$Prop4[1,2]
Prop4_Upper <- propPack$Quants$Prop4[2,2]
Prop5_Lower <- propPack$Quants$Prop5[1,2]
Prop5_Upper <- propPack$Quants$Prop5[2,2]
sim_row <- data.frame("sample_size"=n_sims_data,
"latent.r.attrit_param"=gen.tmp$sim_params["latent.r.coef.attrit_param"],
"latent.r.hetero_param"=gen.tmp$sim_params["latent.r.coef.hetero_attrit"],
"latent.r.confounder"=gen.tmp$sim_params["latent.r.coef.confounder"],
"latent.r.instr"=gen.tmp$sim_params["latent.r.coef.instr"],
"y.star.int"=gen.tmp$sim_params["y.star.intercept"],
"y.star.D"=gen.tmp$sim_params["y.star.D_coef"],
"y.star.X"=gen.tmp$sim_params["y.star.X_coef"],
"y.star.DX"=gen.tmp$sim_params["y.star.DX_coef"],
"y.star.confounder"=gen.tmp$sim_params["y.star.confounder"],
"ATE_True"=ATE_True,
"ATER1_True"=ATER1_True,
"OLS_NC_Est"=OLS_NC_Est,
"OLS_C_Est"=OLS_C_Est,
"Prop1_Est"=Prop1_Est,
"Prop2_Est"=Prop2_Est,
"Prop3_Est"=Prop3_Est,
"Prop4_Est"=Prop4_Est,
"Prop5_Est"=Prop5_Est,
"Prop1_MinWeight"=Prop1_MinWeight,
"Prop2_MinWeight"=Prop2_MinWeight,
"Prop3_MinWeight"=Prop3_MinWeight,
"Prop4_MinWeight"=Prop4_MinWeight,
"Prop5_MinWeight"=Prop5_MinWeight,
"Prop1_MaxWeight"=Prop1_MaxWeight,
"Prop2_MaxWeight"=Prop2_MaxWeight,
"Prop3_MaxWeight"=Prop3_MaxWeight,
"Prop4_MaxWeight"=Prop4_MaxWeight,
"Prop5_MaxWeight"=Prop5_MaxWeight,
"OLS_NC_SE"=OLS_NC_SE,
"OLS_C_SE"=OLS_C_SE,
"Prop1_SE"=Prop1_SE,
"Prop2_SE"=Prop2_SE,
"Prop3_SE"=Prop3_SE,
"Prop4_SE"=Prop4_SE,
"Prop5_SE"=Prop5_SE,
"OLS_NC_Lower"=OLS_NC_Lower,
"OLS_C_Lower"=OLS_C_Lower,
"Prop1_Lower"=Prop1_Lower,
"Prop2_Lower"=Prop2_Lower,
"Prop3_Lower"=Prop3_Lower,
"Prop4_Lower"=Prop4_Lower,
"Prop5_Lower"=Prop5_Lower,
"OLS_NC_Upper"=OLS_NC_Upper,
"OLS_C_Upper"=OLS_C_Upper,
"Prop1_Upper"=Prop1_Upper,
"Prop2_Upper"=Prop2_Upper,
"Prop3_Upper"=Prop3_Upper,
"Prop4_Upper"=Prop4_Upper,
"Prop5_Upper"=Prop5_Upper
)
return(sim_row)
rm(list = c("gen.tmp", "data.tmp1", "Prop1", "Prop2", "Prop3", "Prop4", "Prop5"))
}
clusterExport(cl, c('dgp.func',
'ind_sim',
'bootstrapDelta',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam',
'n_sims_data',
'storage_df'),
envir = environment())
parSapply(cl = cl, 1:dim(storage_df)[1], FUN = function(x) ind_sim(storage_df[x,]))
}
# sim_results <- data.frame("sample_size"=c(100,100,100,100,100,100),
#                           "latent.r.attrit_param"=c(0,0.2,0.4,0.6,0.8,1),
#                           "latent.r.hetero_param"=c(0,0,0,0,0,0),
#                           "latent.r.confounder"=c(1,1,1,1,1,1),
#                           "latent.r.instr"=c(1,1,1,1,1,1),
#                           "y.star.int"=rep(1,6),
#                           "y.star.D"=rep(1,6),
#                           "y.star.X"=rep(0.5,6),
#                           "y.star.DX"=rep(0,6),
#                           "y.star.confounder"=rep(1,6),
#                           "ATE_True"=NA,
#                           "ATER1_True"=NA,
#                           "OLS_NC_Est"=NA,
#                           "OLS_C_Est"=NA,
#                           "Prop1_Est"=NA,
#                           "Prop2_Est"=NA,
#                           "Prop3_Est"=NA,
#                           "Prop4_Est"=NA,
#                           "Prop5_Est"=NA,
#                           "Prop1_MinWeight"=NA,
#                           "Prop2_MinWeight"=NA,
#                           "Prop3_MinWeight"=NA,
#                           "Prop4_MinWeight"=NA,
#                           "Prop5_MinWeight"=NA,
#                           "Prop1_MaxWeight"=NA,
#                           "Prop2_MaxWeight"=NA,
#                           "Prop3_MaxWeight"=NA,
#                           "Prop4_MaxWeight"=NA,
#                           "Prop5_MaxWeight"=NA,
#                           "OLS_NC_SE"=NA,
#                           "OLS_C_SE"=NA,
#                           "Prop1_SE"=NA,
#                           "Prop2_SE"=NA,
#                           "Prop3_SE"=NA,
#                           "Prop4_SE"=NA,
#                           "Prop5_SE"=NA,
#                           "OLS_NC_Lower"=NA,
#                           "OLS_C_Lower"=NA,
#                           "Prop1_Lower"=NA,
#                           "Prop2_Lower"=NA,
#                           "Prop3_Lower"=NA,
#                           "Prop4_Lower"=NA,
#                           "Prop5_Lower"=NA,
#                           "OLS_NC_Upper"=NA,
#                           "OLS_C_Upper"=NA,
#                           "Prop1_Upper"=NA,
#                           "Prop2_Upper"=NA,
#                           "Prop3_Upper"=NA,
#                           "Prop4_Upper"=NA,
#                           "Prop5_Upper"=NA
# )
no_cores <- 4#detectCores() -1 # set to use 4 cores to leave 4 more open
cl <- makeCluster(no_cores)
clusterExport(cl, c('dgp.func',
#'ind_sim',
'sim_func',
'estimateDelta',
'bootstrapDelta',
'makeCluster',
'clusterExport',
'parLapply',
'parSapply',
'stopCluster'),
envir = environment())
sample_size=seq(200,1000,by=200)
latent.r.attrit_param=seq(0,3,by=1)
latent.r.hetero_param=seq(0,3,by=1)
latent.r.confounder=seq(0,3,by=1)
latent.r.instr=seq(0,3,by=1)
all_param_values <- expand.grid(sample_size, latent.r.attrit_param, latent.r.hetero_param,
latent.r.confounder, latent.r.instr)
all_param_values <- do.call(rbind, replicate(20, as.data.frame(all_param_values), simplify=FALSE))
sim_results <- data.frame("y.star.int"=rep(1,dim(all_param_values)[1]),
"y.star.D"=rep(1,dim(all_param_values)[1]),
"y.star.X"=rep(0.5,dim(all_param_values)[1]),
"y.star.DX"=rep(0,dim(all_param_values)[1]),
#"y.star.confounder"=rep(NA, dim(all_param_values)[1]), # we want the confounder effect to be the same at both stages
"ATE_True"=rep(NA, dim(all_param_values)[1]),
"ATER1_True"=rep(NA, dim(all_param_values)[1]),
"OLS_NC_Est"=rep(NA, dim(all_param_values)[1]),
"OLS_C_Est"=rep(NA, dim(all_param_values)[1]),
"Prop1_Est"=rep(NA, dim(all_param_values)[1]),
"Prop2_Est"=rep(NA, dim(all_param_values)[1]),
"Prop3_Est"=rep(NA, dim(all_param_values)[1]),
"Prop4_Est"=rep(NA, dim(all_param_values)[1]),
"Prop5_Est"=rep(NA, dim(all_param_values)[1]),
"Prop1_MinWeight"=rep(NA, dim(all_param_values)[1]),
"Prop2_MinWeight"=rep(NA, dim(all_param_values)[1]),
"Prop3_MinWeight"=rep(NA, dim(all_param_values)[1]),
"Prop4_MinWeight"=rep(NA, dim(all_param_values)[1]),
"Prop5_MinWeight"=rep(NA, dim(all_param_values)[1]),
"Prop1_MaxWeight"=rep(NA, dim(all_param_values)[1]),
"Prop2_MaxWeight"=rep(NA, dim(all_param_values)[1]),
"Prop3_MaxWeight"=rep(NA, dim(all_param_values)[1]),
"Prop4_MaxWeight"=rep(NA, dim(all_param_values)[1]),
"Prop5_MaxWeight"=rep(NA, dim(all_param_values)[1]),
"OLS_NC_SE"=rep(NA, dim(all_param_values)[1]),
"OLS_C_SE"=rep(NA, dim(all_param_values)[1]),
"Prop1_SE"=rep(NA, dim(all_param_values)[1]),
"Prop2_SE"=rep(NA, dim(all_param_values)[1]),
"Prop3_SE"=rep(NA, dim(all_param_values)[1]),
"Prop4_SE"=rep(NA, dim(all_param_values)[1]),
"Prop5_SE"=rep(NA, dim(all_param_values)[1]),
"OLS_NC_Lower"=rep(NA, dim(all_param_values)[1]),
"OLS_C_Lower"=rep(NA, dim(all_param_values)[1]),
"Prop1_Lower"=rep(NA, dim(all_param_values)[1]),
"Prop2_Lower"=rep(NA, dim(all_param_values)[1]),
"Prop3_Lower"=rep(NA, dim(all_param_values)[1]),
"Prop4_Lower"=rep(NA, dim(all_param_values)[1]),
"Prop5_Lower"=rep(NA, dim(all_param_values)[1]),
"OLS_NC_Upper"=rep(NA, dim(all_param_values)[1]),
"OLS_C_Upper"=rep(NA, dim(all_param_values)[1]),
"Prop1_Upper"=rep(NA, dim(all_param_values)[1]),
"Prop2_Upper"=rep(NA, dim(all_param_values)[1]),
"Prop3_Upper"=rep(NA, dim(all_param_values)[1]),
"Prop4_Upper"=rep(NA, dim(all_param_values)[1]),
"Prop5_Upper"=rep(NA, dim(all_param_values)[1])
)
# making the confounders have the same values by repeating the latent.r.confounder
sim_results <- cbind(all_param_values, all_param_values$Var4, sim_results)
colnames(sim_results)[1:6] <- c("sample_size", "latent.r.attrit_param",
"latent.r.hetero_param",
"latent.r.confounder",
"latent.r.instr", "y.star.confounder")
######################################################
# sample_size=rep(2000,500)
# latent.r.attrit_param=rep(2,500)
# latent.r.hetero_param=rep(1,500)
# latent.r.confounder=rep(1,500)
# latent.r.instr=rep(2,500)
#
# #all_param_values <- expand.grid(sample_size, latent.r.attrit_param, latent.r.hetero_param,
# #                                latent.r.confounder, latent.r.instr)
#
# all_param_values <- cbind(sample_size, latent.r.attrit_param, latent.r.hetero_param,
#                           latent.r.confounder, latent.r.instr)
#
# sim_results <- data.frame("y.star.int"=rep(1,dim(all_param_values)[1]),
#                           "y.star.D"=rep(1,dim(all_param_values)[1]),
#                           "y.star.X"=rep(0.5,dim(all_param_values)[1]),
#                           "y.star.DX"=rep(1,dim(all_param_values)[1]),
#                           "y.star.confounder"=rep(1,dim(all_param_values)[1]),
#                           "ATE_True"=rep(NA, dim(all_param_values)[1]),
#                           "ATER1_True"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_NC_Est"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_C_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_Est"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_MinWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_MinWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_MinWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_MinWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_MinWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_MaxWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_MaxWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_MaxWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_MaxWeight"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_MaxWeight"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_NC_SE"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_C_SE"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_SE"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_SE"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_SE"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_SE"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_SE"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_NC_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_C_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_Lower"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_NC_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "OLS_C_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "Prop1_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "Prop2_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "Prop3_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "Prop4_Upper"=rep(NA, dim(all_param_values)[1]),
#                           "Prop5_Upper"=rep(NA, dim(all_param_values)[1])
# )
#
# sim_results <- cbind(all_param_values, sim_results)
# colnames(sim_results)[1:5] <- c("sample_size", "latent.r.attrit_param",
#                                 "latent.r.hetero_param",
#                                 "latent.r.confounder",
#                                 "latent.r.instr")
sample_size=seq(200,1000,by=200)
latent.r.attrit_param=seq(0,3,by=1)
latent.r.hetero_param=seq(0,3,by=1)
latent.r.confounder=seq(0,3,by=1)
latent.r.instr=seq(0,3,by=1)
all_param_values <- expand.grid(sample_size, latent.r.attrit_param, latent.r.hetero_param,
latent.r.confounder, latent.r.instr)
all_param_values <- do.call(rbind, replicate(20, as.data.frame(all_param_values), simplify=FALSE))
View(all_param_values)
