'gam'))
clusterExport(BootsCluster,
Y ~ D,
~ Z,
TestData,
R ~ ,
binomial(link = logit),
D ~ .,
binomial(link = logit),
1000,
c(0.05, 0.95),
'Population',
'gam')
BootsList <- lapply(BootsCluster, 1000, TestData[sample(x = nrow(TestData),  size = 1000, replace = T), ])
BootsList <- lapply(BootsCluster, 1:1000, TestData[sample(x = nrow(TestData),  size = 1000, replace = T), ])
BootsList <- lapply(BootsCluster, 1:1000,
fun = function(x) TestData[sample(x = nrow(TestData),  size = nrow(TestData), replace = T), ])
BootsList <- lapply(BootsCluster, X = 1:1000,
fun = function(x) TestData[sample(x = nrow(TestData),  size = nrow(TestData), replace = T), ])
bootstrapDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit),
nBoots = 1000,
quantiles = c(0.05, 0.95),
effectType = 'Population',
nCores = 1
) {
# Make cluster
BootsCluster <- makeCluster(nCores)
clusterExport(BootsCluster, c('regressionFormula',
'instrumentFormula',
'data',
'p_W_Formula',
'p_W_Method',
'PiFormula',
'PiMethod',
'nBoots',
'quantiles',
'effectType',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam'),
envir = environment())
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(BootsCluster, X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)}
Boot <- bootstrapDelta(Y ~ D,
instrumentFormula = ~ Z,
data = ObsData,
effectType = 'Both',
nCores = 4)
#' Estimating standard errors for ATEs given non-random attrition
#'
#' \code{bootstrapDeltaP} estimates standard errors of the average treatment effect (ATE) in parallel
#' under conditions of non-random attrition.
#'
#' @param regressionFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{regressionFormula}
#' is the model which will be used to estimate the ATE after accounting for non-random
#' attrition. Formula must be of the form Y ~ D + ..., where Y is the outcome, D is the treatment,
#' and ... represents any set of other covariates.
#' @param instrumentFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{instrumentFormula}
#' is the model which estimates the weights used in the model which estimates the ATE.
#' Formula must be of the form ~ Z1 + ..., where Z1 represents some instrumental variable,
#' and ... represents any other desired instrumental variables.
#' @param data A data frame which contains all variables to be used in both
#' \code{regressionFormula} and \code{instrumentFormula}.
#' @param weightMethod An optional string indicating the estimation method to be used for
#' generating the weights.  The default method is generalized linear model ("glm").
#' @param nBoots Numeric value defining the number of bootstrap samples; the default number
#' of bootstrap replications is 1,000.
#'
#' @details
#' The function estimates standard errors for the average treatment effect (ATE)
#' after accounting for non-random attrition. After drawing random samples with
#' replacement from the provided data (by default, 1000 samples), the function
#' estimates with the bootstrapped sample the mean value, median, and standard errors
#' based on the bootstrapped replications. The function, thus, provides a measure of
#' accuracy to the point estimates for the ATE.
#'
#' @references Huber, Martin (2012): "Identification of Average Treatment Effects in
#' Social Experiments Under Alternative Forms of Attrition.", Journal of
#' Educational and Behavioral Statistics, vol. 37, no. 3, 443-474.
#'
#' @return A list of three vectors for mean, median, and standard errors of the ATE.
#'  \item{MeanEst}{A numeric vector of mean values of the ATE for treatment
#'  and control group.}
#'  \item{MedianEst}{A numeric vector of the median of the ATE for treatment
#'  and control group.}
#'  \item{SE}{A numeric vector of standard errors of the ATE for treatment
#'  and control group.}
#'  \item{Quantiles}{A matrix containing estimates that correspond to the quantile (row)
#'  and coefficient (column). By defualt it returns the 5\% and 95\% quantiles.}
#'  \item{Matrix}{A matrix containing the bootstrapped coefficient estimates, where each
#'  row corresponds to a covaraite, and each column corresponds to a bootstrap iteration.}
#' @author Ryden Butler, David Miller, Jonas Markgraf, and Hyunjoo Oh
#'
#' @rdname bootstrapDelta
#' @import 'parallel'
#' @export
bootstrapDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit),
nBoots = 1000,
quantiles = c(0.05, 0.95),
effectType = 'Population',
nCores = 1
) {
# Make cluster
BootsCluster <- makeCluster(nCores)
clusterExport(BootsCluster, c('regressionFormula',
'instrumentFormula',
'data',
'p_W_Formula',
'p_W_Method',
'PiFormula',
'PiMethod',
'nBoots',
'quantiles',
'effectType',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam'),
envir = environment())
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(BootsCluster, X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)}
Boot <- bootstrapDelta(Y ~ D,
instrumentFormula = ~ Z,
data = ObsData,
effectType = 'Both',
nCores = 4)
#' Estimating standard errors for ATEs given non-random attrition
#'
#' \code{bootstrapDeltaP} estimates standard errors of the average treatment effect (ATE) in parallel
#' under conditions of non-random attrition.
#'
#' @param regressionFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{regressionFormula}
#' is the model which will be used to estimate the ATE after accounting for non-random
#' attrition. Formula must be of the form Y ~ D + ..., where Y is the outcome, D is the treatment,
#' and ... represents any set of other covariates.
#' @param instrumentFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{instrumentFormula}
#' is the model which estimates the weights used in the model which estimates the ATE.
#' Formula must be of the form ~ Z1 + ..., where Z1 represents some instrumental variable,
#' and ... represents any other desired instrumental variables.
#' @param data A data frame which contains all variables to be used in both
#' \code{regressionFormula} and \code{instrumentFormula}.
#' @param weightMethod An optional string indicating the estimation method to be used for
#' generating the weights.  The default method is generalized linear model ("glm").
#' @param nBoots Numeric value defining the number of bootstrap samples; the default number
#' of bootstrap replications is 1,000.
#'
#' @details
#' The function estimates standard errors for the average treatment effect (ATE)
#' after accounting for non-random attrition. After drawing random samples with
#' replacement from the provided data (by default, 1000 samples), the function
#' estimates with the bootstrapped sample the mean value, median, and standard errors
#' based on the bootstrapped replications. The function, thus, provides a measure of
#' accuracy to the point estimates for the ATE.
#'
#' @references Huber, Martin (2012): "Identification of Average Treatment Effects in
#' Social Experiments Under Alternative Forms of Attrition.", Journal of
#' Educational and Behavioral Statistics, vol. 37, no. 3, 443-474.
#'
#' @return A list of three vectors for mean, median, and standard errors of the ATE.
#'  \item{MeanEst}{A numeric vector of mean values of the ATE for treatment
#'  and control group.}
#'  \item{MedianEst}{A numeric vector of the median of the ATE for treatment
#'  and control group.}
#'  \item{SE}{A numeric vector of standard errors of the ATE for treatment
#'  and control group.}
#'  \item{Quantiles}{A matrix containing estimates that correspond to the quantile (row)
#'  and coefficient (column). By defualt it returns the 5\% and 95\% quantiles.}
#'  \item{Matrix}{A matrix containing the bootstrapped coefficient estimates, where each
#'  row corresponds to a covaraite, and each column corresponds to a bootstrap iteration.}
#' @author Ryden Butler, David Miller, Jonas Markgraf, and Hyunjoo Oh
#'
#' @rdname bootstrapDelta
#' @import 'parallel'
#' @export
bootstrapDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit),
nBoots = 1000,
quantiles = c(0.05, 0.95),
effectType = 'Population',
nCores = 1
) {
# Make cluster
BootsCluster <- makeCluster(nCores)
clusterExport(BootsCluster, c('regressionFormula',
'instrumentFormula',
'data',
'p_W_Formula',
'p_W_Method',
'PiFormula',
'PiMethod',
'nBoots',
'quantiles',
'effectType',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam'),
envir = environment())
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(BootsCluster, X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
Estimates <- list()}
#' Estimating standard errors for ATEs given non-random attrition
#'
#' \code{bootstrapDeltaP} estimates standard errors of the average treatment effect (ATE) in parallel
#' under conditions of non-random attrition.
#'
#' @param regressionFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{regressionFormula}
#' is the model which will be used to estimate the ATE after accounting for non-random
#' attrition. Formula must be of the form Y ~ D + ..., where Y is the outcome, D is the treatment,
#' and ... represents any set of other covariates.
#' @param instrumentFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{instrumentFormula}
#' is the model which estimates the weights used in the model which estimates the ATE.
#' Formula must be of the form ~ Z1 + ..., where Z1 represents some instrumental variable,
#' and ... represents any other desired instrumental variables.
#' @param data A data frame which contains all variables to be used in both
#' \code{regressionFormula} and \code{instrumentFormula}.
#' @param weightMethod An optional string indicating the estimation method to be used for
#' generating the weights.  The default method is generalized linear model ("glm").
#' @param nBoots Numeric value defining the number of bootstrap samples; the default number
#' of bootstrap replications is 1,000.
#'
#' @details
#' The function estimates standard errors for the average treatment effect (ATE)
#' after accounting for non-random attrition. After drawing random samples with
#' replacement from the provided data (by default, 1000 samples), the function
#' estimates with the bootstrapped sample the mean value, median, and standard errors
#' based on the bootstrapped replications. The function, thus, provides a measure of
#' accuracy to the point estimates for the ATE.
#'
#' @references Huber, Martin (2012): "Identification of Average Treatment Effects in
#' Social Experiments Under Alternative Forms of Attrition.", Journal of
#' Educational and Behavioral Statistics, vol. 37, no. 3, 443-474.
#'
#' @return A list of three vectors for mean, median, and standard errors of the ATE.
#'  \item{MeanEst}{A numeric vector of mean values of the ATE for treatment
#'  and control group.}
#'  \item{MedianEst}{A numeric vector of the median of the ATE for treatment
#'  and control group.}
#'  \item{SE}{A numeric vector of standard errors of the ATE for treatment
#'  and control group.}
#'  \item{Quantiles}{A matrix containing estimates that correspond to the quantile (row)
#'  and coefficient (column). By defualt it returns the 5\% and 95\% quantiles.}
#'  \item{Matrix}{A matrix containing the bootstrapped coefficient estimates, where each
#'  row corresponds to a covaraite, and each column corresponds to a bootstrap iteration.}
#' @author Ryden Butler, David Miller, Jonas Markgraf, and Hyunjoo Oh
#'
#' @rdname bootstrapDelta
#' @import 'parallel'
#' @export
bootstrapDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit),
nBoots = 1000,
quantiles = c(0.05, 0.95),
effectType = 'Population',
nCores = 1
) {
# Make cluster
BootsCluster <- makeCluster(nCores)
clusterExport(BootsCluster, c('regressionFormula',
'instrumentFormula',
'data',
'p_W_Formula',
'p_W_Method',
'PiFormula',
'PiMethod',
'nBoots',
'quantiles',
'effectType',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam'),
envir = environment())
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(BootsCluster, X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
Estimates <- list()
}
Boot <- bootstrapDelta(Y ~ D,
instrumentFormula = ~ Z,
data = ObsData,
effectType = 'Both',
nCores = 4)
#' Estimating standard errors for ATEs given non-random attrition
#'
#' \code{bootstrapDeltaP} estimates standard errors of the average treatment effect (ATE) in parallel
#' under conditions of non-random attrition.
#'
#' @param regressionFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{regressionFormula}
#' is the model which will be used to estimate the ATE after accounting for non-random
#' attrition. Formula must be of the form Y ~ D + ..., where Y is the outcome, D is the treatment,
#' and ... represents any set of other covariates.
#' @param instrumentFormula An object of class \code{formula} (or one that can be coerced to
#' that class); a symbolic description of the model to be fitted.  \code{instrumentFormula}
#' is the model which estimates the weights used in the model which estimates the ATE.
#' Formula must be of the form ~ Z1 + ..., where Z1 represents some instrumental variable,
#' and ... represents any other desired instrumental variables.
#' @param data A data frame which contains all variables to be used in both
#' \code{regressionFormula} and \code{instrumentFormula}.
#' @param weightMethod An optional string indicating the estimation method to be used for
#' generating the weights.  The default method is generalized linear model ("glm").
#' @param nBoots Numeric value defining the number of bootstrap samples; the default number
#' of bootstrap replications is 1,000.
#'
#' @details
#' The function estimates standard errors for the average treatment effect (ATE)
#' after accounting for non-random attrition. After drawing random samples with
#' replacement from the provided data (by default, 1000 samples), the function
#' estimates with the bootstrapped sample the mean value, median, and standard errors
#' based on the bootstrapped replications. The function, thus, provides a measure of
#' accuracy to the point estimates for the ATE.
#'
#' @references Huber, Martin (2012): "Identification of Average Treatment Effects in
#' Social Experiments Under Alternative Forms of Attrition.", Journal of
#' Educational and Behavioral Statistics, vol. 37, no. 3, 443-474.
#'
#' @return A list of three vectors for mean, median, and standard errors of the ATE.
#'  \item{MeanEst}{A numeric vector of mean values of the ATE for treatment
#'  and control group.}
#'  \item{MedianEst}{A numeric vector of the median of the ATE for treatment
#'  and control group.}
#'  \item{SE}{A numeric vector of standard errors of the ATE for treatment
#'  and control group.}
#'  \item{Quantiles}{A matrix containing estimates that correspond to the quantile (row)
#'  and coefficient (column). By defualt it returns the 5\% and 95\% quantiles.}
#'  \item{Matrix}{A matrix containing the bootstrapped coefficient estimates, where each
#'  row corresponds to a covaraite, and each column corresponds to a bootstrap iteration.}
#' @author Ryden Butler, David Miller, Jonas Markgraf, and Hyunjoo Oh
#'
#' @rdname bootstrapDelta
#' @import 'parallel'
#' @export
bootstrapDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit),
nBoots = 1000,
quantiles = c(0.05, 0.95),
effectType = 'Population',
nCores = 1
) {
# Make cluster
BootsCluster <- makeCluster(nCores)
clusterExport(BootsCluster, c('regressionFormula',
'instrumentFormula',
'data',
'p_W_Formula',
'p_W_Method',
'PiFormula',
'PiMethod',
'nBoots',
'quantiles',
'effectType',
'estimateDelta',
'calculateWeights',
'probabilityFits',
'gam'),
envir = environment())
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(BootsCluster, X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
Estimates <- list()
if(effectType == 'Respondent' | effectType == 'Both'){
Estimates$Resp <- parSapply(BootsCluster, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
if(effectType == 'Population' | effectType == 'Both'){
Estimates$Pop <- parSapply(BootsCluster, BootsList,
function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$PopulationDelta$coefficients
)
}
# Calculate results: mean, median, and standard errors, based on bootstrapped replications
SEs <- lapply(Estimates, function(x) apply(x, 1, sd))
Means <- lapply(Estimates, rowMeans)
Medians <- lapply(Estimates, function(x) apply(x, 1, median))
# Note that the bootstrapping results in some NA coefficient estimates (colinearity? too much missingness?)
# As a result, na.rm is required here for the quantiles (though strangely, not for the other functions)
# This is unnecessary with larger sample sizes, and may disappear with additional noise
# All efforts should be taken to have na.rm == F, as wanton removal of NAs can gloss over major errors
# If na.rm must be true, we should include a warning message if NAs are found in the CoefMatrix
# Additionally we may want an error thrown if the number of NAs exceeds some tolerable threshold
# Currently the NA problem appears more frequently (possibly exclusively) when calculating the ATE
Quantiles <- lapply(Estimates, function(x) apply(x, 1, function(y) quantile(y, quantiles, na.rm=T)))
# Stopping the cluster
stopCluster(BootsCluster)
# return list with mean, median, and standard error of estimated for treatment and control
return(list(MeanEst = Means,
MedianEst = Medians,
SE = SEs,
Quantiles = Quantiles,
Matrix = Estimates
)
)
}
Boot <- bootstrapDelta(Y ~ D,
instrumentFormula = ~ Z,
data = ObsData,
effectType = 'Both',
nCores = 4)
library(devtools)
library(roxygen2)
library(MASS)
# DO NOT RUN THE FOLLOWING LINE
#### package.skeleton('estimateDelta')
# Compile latest package and re-documents
Current <- as.package('attritR')
load_all(Current)
document(Current)
# This will tak a moment ...
demo(plotEstimates)
### Check Proposition 4:
simulateData <- function(N = 1000,
treatmentEffectR = c(-2,2),
covariateEffectR = 1,
instrumentEffectR = 1,
treatmentEffectY = 1,
covariateEffectY = 1,
interactionEffectY = .25
){
X <- runif(n = N, min = -1, max = 1)
Z <- runif(n = N, min = -1, max = 2)
D <- rbinom(n = N, size = 1, prob = 0.5)
# For attrition on unobservables
UV <- mvrnorm(n = N, mu = c(0,0), Sigma = matrix(c(1, 0.8, 0.8, 1), nrow = 2))
U <- UV[ , 1]
V <- UV[ , 2]
# Counterfactual treatment effects
YTreatment <- treatmentEffectY + covariateEffectY*X + interactionEffectY*D*X + U
YControl <-  covariateEffectY*X + U
# Counterfactual ATE | All
ATE <- mean(YTreatment) - mean(YControl)
Sims <- lapply(seq(treatmentEffectR[1], treatmentEffectR[2], 0.1), function(currentR) {
# Realized treatment effects and attrition
Y <- treatmentEffectY*D + covariateEffectY*X + interactionEffectY*D*X + U
R <- currentR*D + covariateEffectR*X + instrumentEffectR*Z + V > 0
Y[!R] <- NA
# Combines realized data
SimData <- data.frame(Y, D, X, Z)
# ATE | Response
ATR <- mean(Y[R & D]) - mean(Y[R & !D])
return(list(ATR = ATR, SimData = SimData))
}
)
ATR <- unlist(lapply(Sims, function(sim) sim$ATR))
SimData <- lapply(Sims, function(sim) sim$SimData)
return(list(ATE = ATE, ATR = ATR, SimData = SimData))
}
ObsData <- simulateData()$SimData[[1]]
Boot <- bootstrapDelta(Y ~ D,
instrumentFormula = ~ Z,
data = ObsData,
effectType = 'Both',
nCores = 4)
library(gam)
