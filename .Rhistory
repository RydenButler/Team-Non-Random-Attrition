tstats <- sapply(1:1000, FUN=function(x) summary(lm(Y[,x] ~ mydata[,,x]))$coefficients[,3])
#for (i in 1:1000){
#  tstats[i,] <- summary(lm(Y[,i] ~ mydata[,,i]))$coefficients[,3]
#}
### 5 Return a list containing two matrices: the coefficients and
### the t-statistics
coefs <- as.matrix(coefs)
tstats <- as.matrix(tstats)
outputlist <- list(coefs=coefs, tstats=tstats)
return(outputlist)
}
improved_this <- function(){
beta.fun <- function(x){                      # function to create Y values
x %*% Beta + rnorm(n=length(x %*% Beta))
}
Y <- apply(mydata, MARGIN=3, FUN=beta.fun)    # apply y value function
### 3 Run 1,000 regressions across all of this simulated data.  Have as
### the output a 1000 by 6 matrix of estimated regression coefficients.
coefs <- matrix(NA, nrow=1000, ncol=6)
coefs <- sapply(1:1000, FUN=function(x) coef(lm(Y[,x] ~ mydata[,,x])))
#for (i in 1:1000){
#  coefs[i,] <- coef(lm(Y[,i] ~ mydata[,,i]))
#}
### 4 Alter your code so that you now collect t-statistics for all
### 1,000 regressions for all six coefficients.
tstats <- matrix(NA, nrow=1000, ncol=6)
tstats <- sapply(1:1000, FUN=function(x) summary(lm(Y[,x] ~ mydata[,,x]))$coefficients[,3])
#for (i in 1:1000){
#  tstats[i,] <- summary(lm(Y[,i] ~ mydata[,,i]))$coefficients[,3]
#}
### 5 Return a list containing two matrices: the coefficients and
### the t-statistics
coefs <- as.matrix(coefs)
tstats <- as.matrix(tstats)
outputlist <- list(coefs=coefs, tstats=tstats)
return(outputlist)
}
microbenchmark(improve_this(), improved_this(), times=5)
microbenchmark(improve_this(), improved_this(), times=5)
improved_this <- function(){
beta.fun <- function(x){                      # function to create Y values
x %*% Beta + rnorm(n=length(x %*% Beta))
}
Y <- apply(mydata, MARGIN=3, FUN=beta.fun)    # apply y value function
### 3 Run 1,000 regressions across all of this simulated data.  Have as
### the output a 1000 by 6 matrix of estimated regression coefficients.
#coefs <- matrix(NA, nrow=1000, ncol=6)
coefs <- sapply(1:1000, FUN=function(x) coef(lm(Y[,x] ~ mydata[,,x])))
#for (i in 1:1000){
#  coefs[i,] <- coef(lm(Y[,i] ~ mydata[,,i]))
#}
### 4 Alter your code so that you now collect t-statistics for all
### 1,000 regressions for all six coefficients.
#tstats <- matrix(NA, nrow=1000, ncol=6)
tstats <- sapply(1:1000, FUN=function(x) summary(lm(Y[,x] ~ mydata[,,x]))$coefficients[,3])
#for (i in 1:1000){
#  tstats[i,] <- summary(lm(Y[,i] ~ mydata[,,i]))$coefficients[,3]
#}
### 5 Return a list containing two matrices: the coefficients and
### the t-statistics
coefs <- as.matrix(coefs)
tstats <- as.matrix(tstats)
outputlist <- list(coefs=coefs, tstats=tstats)
return(outputlist)
}
microbenchmark(improve_this(), improved_this(), times=5)
### 1 Make a three dimensional array with dim=c(20,5, 1000) and fill it with random data.
### Think of this as 1000 random datasets with 20 observations and 5 covariates
mydata <- array(sample(1:1000, size=1000, replace=TRUE),dim=c(20,5,1000))
### 2 Make a function to create Y values (for a linear model). The Y-values should be a
### linear combination of the X's plus some normally distributed error.
Beta <- matrix(c(1,2,0,4,0), ncol=1)          # create the betas
beta.fun <- function(x){                      # function to create Y values
x %*% Beta + rnorm(n=length(x %*% Beta))
}
Y <- apply(mydata, MARGIN=3, FUN=beta.fun)    # apply y value function
### 3 Run 1,000 regressions across all of this simulated data.  Have as
### the output a 1000 by 6 matrix of estimated regression coefficients.
coefs <- matrix(NA, nrow=1000, ncol=6)
for (i in 1:1000){
coefs[i,] <- coef(lm(Y[,i] ~ mydata[,,i]))
}
beta.fun <- function(x){                      # function to create Y values
x %*% Beta + rnorm(n=length(x %*% Beta))
}
Y <- apply(mydata, MARGIN=3, FUN=beta.fun)    # apply y value function
### 3 Run 1,000 regressions across all of this simulated data.  Have as
### the output a 1000 by 6 matrix of estimated regression coefficients.
#coefs <- matrix(NA, nrow=1000, ncol=6)
coefs <- sapply(1:1000, FUN=function(x) coef(lm(Y[,x] ~ mydata[,,x])))
#for (i in 1:1000){
#  coefs[i,] <- coef(lm(Y[,i] ~ mydata[,,i]))
#}
coefs <- sapply(1:1000, FUN=function(x) lm(Y[,x] ~ mydata[,,x]))
coefs[1]
coefs[1]
coefs <- sapply(1:1000, FUN=function(x) lm(Y[,x] ~ mydata[,,x]))
lm(Y[,x] ~ mydata[,,x])
coefs <- sapply(1:1000, FUN=function(x) coef(lm(Y[,x] ~ mydata[,,x])))
library(devtools)
library(roxygen2)
Current <- as.package('ATTR')
setwd("C://Users//drmiller1220//Documents//GitHub//Team-Non-Random-Attrition")
Current <- as.package('ATTR')
load_all(Current)
document(Current)
library(parallel)
Treatment <- sample(c(0, 1), 100 , replace = T)
# A dataframe of covariates for later use
Covariates <- data.frame(Binary = sample(x = c(0, 1),
size = length(Treatment),
replace = T),
Continuous = rnorm(n = length(Treatment),
mean = 10,
sd = 3))
# Create vector of instruments
Instrument <- data.frame(Z1 = sample(x = 1:5,
size = length(Treatment),
replace = T,
prob = c(0.3, 0.2, 0.2, 0.2, 0.1)))
# Create vector of Y values, related to D and X
Outcome <- 3*Treatment + 1*Covariates[,1] + 2*Covariates[,2]
# Create probabilistic attrition vector
Attrition <- sapply(1:length(Treatment),
function(x) rbinom(n = 1,
size = 1,
prob = (5*(Treatment[x] + 1) - Instrument[[1]][x])/10))
Outcome[as.logical(Attrition)] <- NA
# MAR missingness in X
Covariates <- as.data.frame(lapply(Covariates,
function(x) x[sample(x = c(TRUE,NA),
size = length(x),
prob = c(0.95, 0.05),
replace = TRUE)]))
# Bind vectors together into single dataset
NoXData <- data.frame(cbind(Outcome, Treatment, Instrument))
FullData <- data.frame(cbind(Outcome, Treatment, Covariates, Instrument))
lm(Outcome ~ Treatment + Binary + Continuous, data = FullData)
regForm <- "Outcome ~ Treatment + Binary + Continuous"
instForm <- Z1
instForm <- "Z1"
instForm <- "~ Z1"
regressionFormula <- "Outcome ~ Treatment + Binary + Continuous"
instrumentFormula <- "~ Z1"
data <- FullData
effectType = 'Respondent'
p_W_Formula = R ~ .
p_W_Method = binomial(link = logit)
PiFormula = D ~ .
PiMethod = binomial(link = logit)
nBoots = 1000
quantiles = c(0.05, 0.95)
effectType = 'Respondent'
num_cores <- detectCores() - 1
# Setting cluster of cores
clust <- makeCluster(num_cores)
BootsList <- parLapply(X = 1:nBoots,
FUN = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
cl <- makeCluster(num_cores)
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(X = 1:nBoots,
FUN = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
cl <- makeCluster(num_cores)
setDefaultCluster(cl)
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(X = 1:nBoots,
FUN = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
clusterExport(cl, "data")
setDefaultCluster(cl)
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
BootsList
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula"))
setDefaultCluster(cl)
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(BootsList,
function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(BootsList,
FUN= function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
stopCluster()
stopCluster(cl)
num_cores <- detectCores() - 1
# Setting cluster of cores
cl <- makeCluster(num_cores)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula"))
setDefaultCluster(cl)
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
CoefMatrix <- parSapply(BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
checkCluster(cl)
if(effectType == 'Respondent'){
CoefMatrix <- sapply(BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
SEs <- parApply(CoefMatrix, 1, sd)
setDefaultCluster(cl, c("data", "regressionFormula", "instrumentFormula", "CoefMatrix"))
exportCluster(cl, c("data", "regressionFormula", "instrumentFormula", "CoefMatrix"))
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "CoefMatrix"))
setDefaultCluster(cl)
SEs <- parApply(CoefMatrix, 1, sd)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "CoefMatrix","BootsList"))
CoefMatrix <- parSapply(BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
cl <- makeCluster(num_cores)
# for Windows computers, you need to explicitly identify which objects from the environment will
# be used in your parallel functions
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula"))
setDefaultCluster(cl)
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
CoefMatrix <- parSapply(BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula","BootsList"))
CoefMatrix <- parSapply(BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
install(pkg="ATTR", local=TRUE)
install(pkg="ATTR", local=TRUE)
Current <- as.package('ATTR')
load_all(Current)
document(Current)
install(pkg="ATTR", local=TRUE)
estimateDelta <- function(regressionFormula,
instrumentFormula,
data,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit)
) {
# Extract model data given formula
ModelData <- model.frame(regressionFormula, data, na.action = NULL)
# Extract instrument data given formula
InstrumentData <- model.frame(instrumentFormula, data, na.action = NULL)
# Calculate weights; add this to data b/c lm() won't recognize the object otherwise
WeightList <- calculateWeights(modelData = ModelData,
instrumentData = InstrumentData,
p_W_Formula = p_W_Formula,
p_W_Method = p_W_Method,
PiFormula = PiFormula,
PiMethod = PiMethod
)
ModelData <- ModelData[!is.na(ModelData[ , 1]), ]
ModelData$Pi <- WeightList$Pi
ModelData$pWxPi <- WeightList$pWxPi
# Estimate Proposition 4:
RespondentModel <- lm(formula = regressionFormula,
weights = Pi,
data = ModelData
)
# Estimate Proposition 5:
AllModel <- lm(formula = regressionFormula,
weights = pWxPi,
data = ModelData
)
return(list(RespondentDelta = RespondentModel,
AllDelta = AllModel
)
)
}
num_cores <- detectCores() - 1
# Setting cluster of cores
cl <- makeCluster(num_cores)
# for Windows computers, you need to explicitly identify which objects from the environment will
# be used in your parallel functions
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula"))
setDefaultCluster(cl)
# Bootstrap data: random sampling of dataset with replacement
BootsList <- parLapply(X = 1:nBoots,
fun = function(x) data[sample(x = nrow(data),
size = nrow(data),
replace = T), ]
)
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta"))
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
calculateWeights <- function(modelData,
instrumentData,
p_W_Formula = R ~ .,
p_W_Method = binomial(link = logit),
PiFormula = D ~ .,
PiMethod = binomial(link = logit)
) {
# Recode Y as R
# R is test participation: if Y is observed, R=1; else R=0
modelData[ , 1] <- as.numeric(!is.na(.subset2(modelData, 1)))
# Rename to R and D for access below
names(modelData)[1:2] <- c('R', 'D')
# IMPORTANT NOTE:
### This modelData must be structured as columns of Y, D, X, Z
### Otherwise the following calculations are incorrect
# Regress R on X + Z; calculate fitted values
modelData$p_W_Fits <- probabilityFits(formula = p_W_Formula,
# Since default formula is R ~ ., we remove D
modelData = data.frame(modelData[ , -2], instrumentData),
method = p_W_Method
)
modelData[modelData$D != 1, ]$p_W_Fits <- (1 - modelData[modelData$D != 1, ]$p_W_Fits)
# Regress D on X + Z
Pi_Fits <- probabilityFits(formula = PiFormula,
# Since default formula is D ~ ., we remove R, while conditioning on R = 1
modelData = modelData[modelData$R == 1 , -1],
method = PiMethod
)
# Treatment propensity scores
Pi_Fits[modelData[modelData$R == 1, ]$D != 1] <-  (1 - Pi_Fits[modelData[modelData$R == 1, ]$D != 1])
# Product of response propensity scores and treatment propensity scores
AllWeights <- modelData[modelData$R == 1, ]$p_W_Fits * Pi_Fits
return(list(pW = modelData$p_W_Fits,
Pi = Pi_Fits,
pWxPi = AllWeights
)
)
}
probabilityFits <- function(formula,
modelData,
method = binomial(link = logit)
) {
# Calculate model
Model <- gam(formula = formula,
family = method,
data = modelData,
maxit = 1000)
# Calculate fitted values
Fits <- predict(object = Model,
newdata = modelData,
type = 'response')
return(Fits)
}
Proposition1 <- function(modelData,
formula = R ~ .,
method = binomial(link = logit)
) {
p <- probabilityFits(formula = formula,
modelData = modelData,
method = method)
p[modelData$R != 1] <- (1 - p(modelData$R != 1))
return(p)
}
Proposition2 <- function(modelData,
formula = D ~ .,
method = binomial(link = logit)
) {
Pi <- probabilityFits(formula = formula,
modelData = modelData,
method = method)
Pi[modelData$D != 1] <- (1 - Pi[modelData$D != 1])
return(Pi)
}
Proposition3 <- function(modelData,
formula = R ~ .,
method = binomial(link = logit)
) {
retunr(Proposition1(modelData,
formula,
method)*Proposition2(modelData,
formula,
method)
)
}
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights"))
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
probabilityFits <- function(formula,
modelData,
method = binomial(link = logit)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits"))
if(effectType == 'Respondent'){
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
}
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits"))
setDefaultCluster(cl)
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
library(gam)
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits", "gam"))
setDefaultCluster(cl)
CoefMatrix <- parSapply(cl=cl, BootsList,
FUN = function(x) estimateDelta(regressionFormula = regressionFormula,
instrumentFormula = instrumentFormula,
data = x
)$RespondentDelta$coefficients
)
SEs <- parApply(CoefMatrix, 1, sd)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits", "gam", "CoefMatrix"))
setDefaultCluster(cl)
# Calculate results: mean, median, and standard errors, based on bootstrapped replications
SEs <- parApply(CoefMatrix, 1, sd)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits", "gam", "CoefMatrix","stats"))
library(stats)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits", "gam", "CoefMatrix","stats"))
setDefaultCluster(cl)
clusterExport(cl, c("data", "regressionFormula", "instrumentFormula", "BootsList", "estimateDelta",
"calculateWeights", "probabilityFits", "gam", "CoefMatrix","sd"))
setDefaultCluster(cl)
# Calculate results: mean, median, and standard errors, based on bootstrapped replications
SEs <- parApply(CoefMatrix, 1, sd)
SEs <- parApply(cl=cl, X=CoefMatrix, MARGIN=1, FUN=function(x) sd(x))
SEs
Means <- rowMeans(CoefMatrix)
Medians <- parApply(cl=cl, X=CoefMatrix, MARGIN=1, FUN=function(x) median(x))
View(CoefMatrix)
stopCluster(clust)
